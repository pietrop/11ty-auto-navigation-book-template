# useState

Gotcha on `useState`, only only does shallow comparison so if you store a deeply nested object, and change some of the deeper attributes, it might not trigger a re-render.

Workaround is to deconstruct the object before saving it to the state. This creates a copy of the object, and react recognizing it as "new" object triggers a re-render.

```jsx
setSomeState({...obj})
```

> (React uses the [Object.is](http://object.is/) comparison algorithm.)

from [https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-dispatch](https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-dispatch)